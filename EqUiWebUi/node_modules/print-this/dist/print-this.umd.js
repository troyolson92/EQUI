(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.printThis = {})));
}(this, (function (exports) { 'use strict';

  const isOldIE = () => {
    const isBrowser = typeof navigator !== "undefined";

    if (!isBrowser) {
      return false;
    }

    return /msie/i.test(navigator.userAgent);
  };

  const getNodes = (selector, fragment = document) => {
    // Easy path first
    if (util.hasDSA()) {
      return Array.from(fragment.querySelectorAll(seletor));
    }

    /*
     * TODO: Add jQuery support. Can we do this in a way that doesn't use the global?
     * Perhaps pass jQuery to this function from the jQuery plugin?
     */

    // Error out if we can't run.
    throw new Error('Support is limited to recent browsers. https://caniuse.com/#feat=queryselector');
  };

  const getNow = () => Date.now === undefined ? new Date().getTime() : Date.now();

  const hasDSA = () => !!(document && document.querySelectorAll);

  const removeNode = node => node.parentNode && node.parentNode.removeChild(node);

  var utilities = /*#__PURE__*/Object.freeze({
    getNodes: getNodes,
    getNow: getNow,
    hasDSA: hasDSA,
    isOldIE: isOldIE,
    removeNode: removeNode
  });

  /**
   *
   * @param {object} [options]
   * @param {document} [sourceDocument]
   * @return {*}
   */
  const getBaseUrl = (options = {}, sourceDocument = document) => {
    const base = sourceDocument.getElementsByTagName('base')[0];
    let baseURL;

    // add base tag to ensure elements use the parent domain
    if (options.base === true && base !== undefined) {
      // take the base tag from the original page
      baseURL = base.href;
    } else if (typeof options.base === "string") {
      // An exact base string is provided
      baseURL = options.base;
    } else {
      // Use the page URL as the base
      baseURL = sourceDocument.location.protocol + "//" + sourceDocument.location.host;
    }

    return baseURL;
  };

  /**
   * Get <base> tag as a string
   * @param {string} url
   * @return {string}
   */
  const getBaseString = (url) => `<base href="${url}">`;

  /**
   * Get <base> tag as an element
   * @param {string} url
   * @param {document} [sourceDocument]
   * @return {HTMLElement}
   */
  const getBaseTag = (url, sourceDocument = document) => {
    const tag = sourceDocument.createElement('base');
    tag.href = url;
    return tag;
  };

  var addBaseTag = /*#__PURE__*/Object.freeze({
    getBaseString: getBaseString,
    getBaseTag: getBaseTag,
    getBaseUrl: getBaseUrl
  });

  /**
   *
   * @param {document} sourceDocument
   * @return {{href: *, media: (*|string)}[]}
   */
  const getLinkedStylesheets = (sourceDocument = document) => {
    return Array.from(sourceDocument.querySelectorAll("link[rel=stylesheet]"))
      .filter(el => !el.disabled)
      .filter(el => el.href !== undefined)
      .map(el => ({
        href: el.href,
        media: el.media || "all",
      }));
  };

  /**
   * @param {document} sourceDocument
   * @return {string[]}
   */
  const getLinksAsText = (sourceDocument = document) => getLinkedStylesheets(sourceDocument)
    .map(link => `<link rel="stylesheet" href="${link.href}" media="${link.media}">`);

  /**
   * @param {document} sourceDocument
   * @return {HTMLElement[]}
   */
  const getLinksAsTags = (sourceDocument = document) => getLinkedStylesheets(sourceDocument)
    .map(link => {
      const el = sourceDocument.createElement('link');
      el.href = link.href;
      el.media = link.media;
      return el;
    });

  /**
   * @param {object} options
   * @param {document} sourceDocument
   * @param {document} targetDocument
   * @return {document}
   */
  const addStyleLinks = (options, sourceDocument, targetDocument) => {
    if (options.importCSS) {
      const head = targetDocument.getElementsByTagName('head')[0];
      getLinksAsTags(sourceDocument).forEach(tag => head.appendChild(tag));
    }
    return targetDocument;
  };

  /**
   * @param {document} sourceDocument
   * @return {{text: string}[]}
   */
  const getStyleTags = (sourceDocument = document) => {
    return Array.from(sourceDocument.getElementsByTagName("style"))
      .filter(el => !el.disabled)
      .map(el => ({
        text: el.textContent,
      }));
  };

  /**
   * @param {document} sourceDocument
   * @return {string[]}
   */
  const getStyleTagsAsText = (sourceDocument = document) => getStyleTags(sourceDocument)
    .map(style => `<style>${style.text}</style>`);


  /**
   * @param {document} sourceDocument
   * @return {HTMLElement[]}
   */
  const getStyleTagsAsTags = (sourceDocument = document) => getStyleTags(sourceDocument)
    .map(style => {
      const el = sourceDocument.createElement('style');
      el.textContent = style.text;
      return el;
    });

  /**
   * @param {object} options
   * @param {document} sourceDocument
   * @param {document} targetDocument
   * @return {document}
   */
  const addStyleTags = (options, sourceDocument, targetDocument) => {
    if (options.importStyle) {
      const head = targetDocument.getElementsByTagName('head')[0];
      getStyleTagsAsTags(sourceDocument).forEach(tag => head.appendChild(tag));
    }
    return targetDocument;
  };

  /**
   * Makes an HTML <link> tag for the provided CSS url
   * @param {string} url
   * @return {HTMLElement}
   */
  const makeLinkTag = (url) => {
    const link = document.createElement('link');
    link.rel="stylesheet";
    link.href = url;
    return link;
  };

  /**
   * @param {object} options
   * @param {document} targetDocument
   * @return {document}
   */
  const loadCSS = (options, targetDocument) => {
    if (options.loadCSS) {
      const head = targetDocument.getElementsByTagName('head')[0];
      const urls = Array.isArray(options.loadCSS) ? options.loadCSS : [options.loadCSS];
      urls.map(makeLinkTag).forEach(tag => head.appendChild(tag));
    }

    return targetDocument;
  };

  /**
   * CSS variables are stored on the html tag when dynamically applied
   * e.g.  document.documentElement.style.setProperty("--foo", bar);
   * @param {object} options
   * @param {document} sourceDocument
   * @param {document} targetDocument
   * @return {document}
   */
  const addCssVariables = (options, sourceDocument, targetDocument) => {
    // TODO: Add a config for this?
    const srcCssText = targetDocument.getElementsByTagName('html')[0].style.cssText;
    const targetHtml = targetDocument.getElementsByTagName('html')[0];

    targetHtml.style.cssText = srcCssText;
    return targetDocument;
  };

  var addStyles = /*#__PURE__*/Object.freeze({
    getLinkedStylesheets: getLinkedStylesheets,
    getLinksAsText: getLinksAsText,
    getLinksAsTags: getLinksAsTags,
    addStyleLinks: addStyleLinks,
    getStyleTags: getStyleTags,
    getStyleTagsAsText: getStyleTagsAsText,
    getStyleTagsAsTags: getStyleTagsAsTags,
    addStyleTags: addStyleTags,
    makeLinkTag: makeLinkTag,
    loadCSS: loadCSS,
    addCssVariables: addCssVariables
  });

  /**
   *
   * @param {object} [options]
   * @param {document} [sourceDocument]
   * @param {document} [targetDocument]
   * @return {document} targetDocument
   */
  const addTitle = (options, sourceDocument, targetDocument) => {
    if (options.title === true) {
      targetDocument.title = sourceDocument.title;
    } else if (options.title) {
      targetDocument.title = options.title;
    }

    return targetDocument;
  };

  var addTitle$1 = /*#__PURE__*/Object.freeze({
    addTitle: addTitle
  });

  const removeInlineStyle = (fragment, selector) => {
    const nodes = getNodes(selector, fragment);

    Array.from(nodes)
      .forEach(node => node.hasAttribute('style') && node.removeAttribute('style'));

    return fragment;
  };

  const options = () => ({
    removeInline: false,            // remove all inline styles from print elements
    removeInlineSelector: "*",      // custom selectors to filter inline styles. removeInline must be true
  });

  const action = (options, document, fragment) => {
    if (options.removeInline === true) {
      removeInlineStyle(fragment, options.removeInlineSelector);
    }
    return fragment;
  };

  var removeInlineStyles = /*#__PURE__*/Object.freeze({
    action: action,
    options: options
  });

  const removeScripts = (fragment) => {
    const scripts = getNodes('script', fragment);
    scripts.forEach(removeNode);
    return fragment;
  };

  const options$1 = () => ({
    removeScripts: true,
  });

  const action$1 = (options, document, fragment) => {
    if (options.removeScripts === true) {
      removeScripts(fragment);
    }
    return fragment;
  };

  var removeScripts$1 = /*#__PURE__*/Object.freeze({
    action: action$1,
    options: options$1
  });

  const modules = [
    addBaseTag,
    addStyles,
    addTitle$1,
    removeInlineStyles,
    removeScripts$1,
  ];

  const buildOptions = modules.reduce((options$$1, module) => ({
    ...options$$1,
    ...modules.options(),
  }), {});

  var contentActions = /*#__PURE__*/Object.freeze({
    buildOptions: buildOptions,
    modules: modules
  });

  const makeIEFrame = (frame) => {
    // Ugly IE hacks due to IE not inheriting document.domain from parent
    // checks if document.domain is set by comparing the host name against document.domain
    var iframeSrc = `javascript:document.write("<head><${"script"}>document.domain=\\"${
    document.domain
  }\\";</${"script"}></head><body></body>")`;

    frame.className = "MSIE";
    frame.src = iframeSrc;
  };

  const makeFrame = () => {
    const frameName = "printThis-" + getNow();
    const frame = document.createElement("iframe");
    frame.name = "printIframe";
    frame.id = frameName;

    if (isOldIE()) {
      makeIEFrame(frame);
    }

    document.body.appendChild(frame);
    return frame;
  };

  var frameBuilder = /*#__PURE__*/Object.freeze({
    makeFrame: makeFrame
  });

  exports.content = contentActions;
  exports.frame = frameBuilder;
  exports.util = utilities;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

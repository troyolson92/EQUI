const isOldIE = () => {
  const isBrowser = typeof navigator !== "undefined";

  if (!isBrowser) {
    return false;
  }

  return /msie/i.test(navigator.userAgent);
};

const getNodes = (selector, fragment = document) => {
  // Easy path first
  if (util.hasDSA()) {
    return Array.from(fragment.querySelectorAll(seletor));
  }

  /*
   * TODO: Add jQuery support. Can we do this in a way that doesn't use the global?
   * Perhaps pass jQuery to this function from the jQuery plugin?
   */

  // Error out if we can't run.
  throw new Error('Support is limited to recent browsers. https://caniuse.com/#feat=queryselector');
};

const getNow = () => Date.now === undefined ? new Date().getTime() : Date.now();

const hasDSA = () => !!(document && document.querySelectorAll);

const removeNode = node => node.parentNode && node.parentNode.removeChild(node);

var utilities = /*#__PURE__*/Object.freeze({
  getNodes: getNodes,
  getNow: getNow,
  hasDSA: hasDSA,
  isOldIE: isOldIE,
  removeNode: removeNode
});

/**
 *
 * @param {object} [options]
 * @param {document} [sourceDocument]
 * @return {*}
 */
const getBaseUrl = (options = {}, sourceDocument = document) => {
  const base = sourceDocument.getElementsByTagName('base')[0];
  let baseURL;

  // add base tag to ensure elements use the parent domain
  if (options.base === true && base !== undefined) {
    // take the base tag from the original page
    baseURL = base.href;
  } else if (typeof options.base === "string") {
    // An exact base string is provided
    baseURL = options.base;
  } else {
    // Use the page URL as the base
    baseURL = sourceDocument.location.protocol + "//" + sourceDocument.location.host;
  }

  return baseURL;
};

/**
 * Get <base> tag as a string
 * @param {string} url
 * @return {string}
 */
const getBaseString = (url) => `<base href="${url}">`;

/**
 * Get <base> tag as an element
 * @param {string} url
 * @param {document} [sourceDocument]
 * @return {HTMLElement}
 */
const getBaseTag = (url, sourceDocument = document) => {
  const tag = sourceDocument.createElement('base');
  tag.href = url;
  return tag;
};

var addBaseTag = /*#__PURE__*/Object.freeze({
  getBaseString: getBaseString,
  getBaseTag: getBaseTag,
  getBaseUrl: getBaseUrl
});

/**
 *
 * @param {document} sourceDocument
 * @return {{href: *, media: (*|string)}[]}
 */
const getLinkedStylesheets = (sourceDocument = document) => {
  return Array.from(sourceDocument.querySelectorAll("link[rel=stylesheet]"))
    .filter(el => !el.disabled)
    .filter(el => el.href !== undefined)
    .map(el => ({
      href: el.href,
      media: el.media || "all",
    }));
};

/**
 * @param {document} sourceDocument
 * @return {string[]}
 */
const getLinksAsText = (sourceDocument = document) => getLinkedStylesheets(sourceDocument)
  .map(link => `<link rel="stylesheet" href="${link.href}" media="${link.media}">`);

/**
 * @param {document} sourceDocument
 * @return {HTMLElement[]}
 */
const getLinksAsTags = (sourceDocument = document) => getLinkedStylesheets(sourceDocument)
  .map(link => {
    const el = sourceDocument.createElement('link');
    el.href = link.href;
    el.media = link.media;
    return el;
  });

/**
 * @param {object} options
 * @param {document} sourceDocument
 * @param {document} targetDocument
 * @return {document}
 */
const addStyleLinks = (options, sourceDocument, targetDocument) => {
  if (options.importCSS) {
    const head = targetDocument.getElementsByTagName('head')[0];
    getLinksAsTags(sourceDocument).forEach(tag => head.appendChild(tag));
  }
  return targetDocument;
};

/**
 * @param {document} sourceDocument
 * @return {{text: string}[]}
 */
const getStyleTags = (sourceDocument = document) => {
  return Array.from(sourceDocument.getElementsByTagName("style"))
    .filter(el => !el.disabled)
    .map(el => ({
      text: el.textContent,
    }));
};

/**
 * @param {document} sourceDocument
 * @return {string[]}
 */
const getStyleTagsAsText = (sourceDocument = document) => getStyleTags(sourceDocument)
  .map(style => `<style>${style.text}</style>`);


/**
 * @param {document} sourceDocument
 * @return {HTMLElement[]}
 */
const getStyleTagsAsTags = (sourceDocument = document) => getStyleTags(sourceDocument)
  .map(style => {
    const el = sourceDocument.createElement('style');
    el.textContent = style.text;
    return el;
  });

/**
 * @param {object} options
 * @param {document} sourceDocument
 * @param {document} targetDocument
 * @return {document}
 */
const addStyleTags = (options, sourceDocument, targetDocument) => {
  if (options.importStyle) {
    const head = targetDocument.getElementsByTagName('head')[0];
    getStyleTagsAsTags(sourceDocument).forEach(tag => head.appendChild(tag));
  }
  return targetDocument;
};

/**
 * Makes an HTML <link> tag for the provided CSS url
 * @param {string} url
 * @return {HTMLElement}
 */
const makeLinkTag = (url) => {
  const link = document.createElement('link');
  link.rel="stylesheet";
  link.href = url;
  return link;
};

/**
 * @param {object} options
 * @param {document} targetDocument
 * @return {document}
 */
const loadCSS = (options, targetDocument) => {
  if (options.loadCSS) {
    const head = targetDocument.getElementsByTagName('head')[0];
    const urls = Array.isArray(options.loadCSS) ? options.loadCSS : [options.loadCSS];
    urls.map(makeLinkTag).forEach(tag => head.appendChild(tag));
  }

  return targetDocument;
};

/**
 * CSS variables are stored on the html tag when dynamically applied
 * e.g.  document.documentElement.style.setProperty("--foo", bar);
 * @param {object} options
 * @param {document} sourceDocument
 * @param {document} targetDocument
 * @return {document}
 */
const addCssVariables = (options, sourceDocument, targetDocument) => {
  // TODO: Add a config for this?
  const srcCssText = targetDocument.getElementsByTagName('html')[0].style.cssText;
  const targetHtml = targetDocument.getElementsByTagName('html')[0];

  targetHtml.style.cssText = srcCssText;
  return targetDocument;
};

var addStyles = /*#__PURE__*/Object.freeze({
  getLinkedStylesheets: getLinkedStylesheets,
  getLinksAsText: getLinksAsText,
  getLinksAsTags: getLinksAsTags,
  addStyleLinks: addStyleLinks,
  getStyleTags: getStyleTags,
  getStyleTagsAsText: getStyleTagsAsText,
  getStyleTagsAsTags: getStyleTagsAsTags,
  addStyleTags: addStyleTags,
  makeLinkTag: makeLinkTag,
  loadCSS: loadCSS,
  addCssVariables: addCssVariables
});

/**
 *
 * @param {object} [options]
 * @param {document} [sourceDocument]
 * @param {document} [targetDocument]
 * @return {document} targetDocument
 */
const addTitle = (options, sourceDocument, targetDocument) => {
  if (options.title === true) {
    targetDocument.title = sourceDocument.title;
  } else if (options.title) {
    targetDocument.title = options.title;
  }

  return targetDocument;
};

var addTitle$1 = /*#__PURE__*/Object.freeze({
  addTitle: addTitle
});

const removeInlineStyle = (fragment, selector) => {
  const nodes = getNodes(selector, fragment);

  Array.from(nodes)
    .forEach(node => node.hasAttribute('style') && node.removeAttribute('style'));

  return fragment;
};

const options = () => ({
  removeInline: false,            // remove all inline styles from print elements
  removeInlineSelector: "*",      // custom selectors to filter inline styles. removeInline must be true
});

const action = (options, document, fragment) => {
  if (options.removeInline === true) {
    removeInlineStyle(fragment, options.removeInlineSelector);
  }
  return fragment;
};

var removeInlineStyles = /*#__PURE__*/Object.freeze({
  action: action,
  options: options
});

const removeScripts = (fragment) => {
  const scripts = getNodes('script', fragment);
  scripts.forEach(removeNode);
  return fragment;
};

const options$1 = () => ({
  removeScripts: true,
});

const action$1 = (options, document, fragment) => {
  if (options.removeScripts === true) {
    removeScripts(fragment);
  }
  return fragment;
};

var removeScripts$1 = /*#__PURE__*/Object.freeze({
  action: action$1,
  options: options$1
});

const modules = [
  addBaseTag,
  addStyles,
  addTitle$1,
  removeInlineStyles,
  removeScripts$1,
];

const buildOptions = modules.reduce((options$$1, module) => ({
  ...options$$1,
  ...modules.options(),
}), {});

var contentActions = /*#__PURE__*/Object.freeze({
  buildOptions: buildOptions,
  modules: modules
});

const makeIEFrame = (frame) => {
  // Ugly IE hacks due to IE not inheriting document.domain from parent
  // checks if document.domain is set by comparing the host name against document.domain
  var iframeSrc = `javascript:document.write("<head><${"script"}>document.domain=\\"${
    document.domain
  }\\";</${"script"}></head><body></body>")`;

  frame.className = "MSIE";
  frame.src = iframeSrc;
};

const makeFrame = () => {
  const frameName = "printThis-" + getNow();
  const frame = document.createElement("iframe");
  frame.name = "printIframe";
  frame.id = frameName;

  if (isOldIE()) {
    makeIEFrame(frame);
  }

  document.body.appendChild(frame);
  return frame;
};

var frameBuilder = /*#__PURE__*/Object.freeze({
  makeFrame: makeFrame
});

export { contentActions as content, frameBuilder as frame, utilities as util };
